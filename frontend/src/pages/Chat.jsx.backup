import React, { useState, useEffect, useRef } from "react";
import { useDispatch, useSelector } from "react-redux";
import { Card, Typography, Space, Divider, Steps, Button, Progress } from "antd";
import { FileTextOutlined, MessageOutlined, VideoCameraOutlined, ClockCircleOutlined } from '@ant-design/icons';
import ResumeUpload from "../cmp/Chat/ResumeUpload";
import InterviewEngine from "../cmp/Chat/InterviewEngine";
import { setCandidateInfo } from "../feat/cand";
import { selectInterviewStatus } from "../feat/intr";

const { Title, Text } = Typography;

const Chat = () => {
  const dispatch = useDispatch();
  const interviewStatus = useSelector(selectInterviewStatus);
  
  const nameRegex = /^[A-Za-z ]{2,}$/;
  const phoneRegex = /^[+]?([0-9\- ]{10,15})$/;
  const emailRegex = /^[^\s@]+@[^@]+\.[^\s@]{2,}$/;
  
  // Basic states
  const [uploadedFile, setUploadedFile] = useState(null);
  const [extractedData, setExtractedData] = useState(null);
  const [currentStep, setCurrentStep] = useState(0);
  const [missingFields, setMissingFields] = useState([]);
  const [currentMissingFieldIndex, setCurrentMissingFieldIndex] = useState(0);
  const [chatInput, setChatInput] = useState('');
  const [chatMessages, setChatMessages] = useState([]);
  const [userInputs, setUserInputs] = useState({
    name: '',
    email: '',
    phone: ''
  });

  // Interview states
  const [isInterviewStarted, setIsInterviewStarted] = useState(false);
  const [interviewResults, setInterviewResults] = useState(null);
  const [questions, setQuestions] = useState([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [currentTimer, setCurrentTimer] = useState(0);
  const [isAnswering, setIsAnswering] = useState(false);
  const [isEvaluating, setIsEvaluating] = useState(false);
  const [isGeneratingQuestion, setIsGeneratingQuestion] = useState(false);
  const [questionStartTime, setQuestionStartTime] = useState(null);
  
  // Current question data
  const [activeQuestion, setActiveQuestion] = useState(null);
  const [allQuestionsAsked, setAllQuestionsAsked] = useState([]);
  
  // Interview flow tracking
  const difficultySequence = ['easy', 'easy', 'medium', 'medium', 'hard', 'hard'];
  const timeSequence = [20, 20, 60, 60, 120, 120]; // seconds
  
  // Refs
  const timerRef = useRef(null);
  const chatContainerRef = useRef(null);

  // Initialize interview engine
  const interviewEngine = InterviewEngine({
    candidateInfo: extractedData?.data,
    resumeText: extractedData?.text,
    onInterviewComplete: (results) => {
      setInterviewResults(results);
    }
  });

  // Timer effect
  useEffect(() => {
    if (isAnswering && currentTimer > 0) {
      timerRef.current = setTimeout(() => {
        setCurrentTimer(currentTimer - 1);
      }, 1000);
    } else if (isAnswering && currentTimer === 0) {
      // Time's up - auto submit
      handleTimeExpired();
    }

    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [currentTimer, isAnswering]);

  // Auto scroll to bottom
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [chatMessages]);

  // Start interview process
  const startInterview = async () => {
    try {
      setIsInterviewStarted(true);
      setCurrentQuestionIndex(0);
      setQuestions([]);
      setAllQuestionsAsked([]);
      
      const startMessage = {
        id: Date.now(),
        type: 'bot',
        message: `üéØ **Starting Your React/Node.js Technical Interview!**

**Interview Format:**
‚Ä¢ 6 Questions Total: 2 Easy ‚Üí 2 Medium ‚Üí 2 Hard
‚Ä¢ Questions generated dynamically by AI
‚Ä¢ Timers: Easy (20s), Medium (60s), Hard (120s)
‚Ä¢ Auto-submit when time expires

Let's begin with Question 1...`
      };
      
      setChatMessages([startMessage]);
      
      // Generate and show first question
      setTimeout(() => {
        generateAndShowNextQuestion();
      }, 2000);
      
    } catch (error) {
      console.error('Failed to start interview:', error);
    }
  };

  // Generate and show the next question
  const generateAndShowNextQuestion = async () => {
    try {
      setIsGeneratingQuestion(true);
      
      const questionNumber = currentQuestionIndex + 1;
      const difficulty = difficultySequence[currentQuestionIndex];
      const timeLimit = timeSequence[currentQuestionIndex];
      
      // Show generating message
      const generatingMessage = {
        id: Date.now(),
        type: 'system',
        message: `ü§ñ Generating Question ${questionNumber}/6 (${difficulty.toUpperCase()})...`
      };
      setChatMessages(prev => [...prev, generatingMessage]);
      
      // Generate question using AI
      const questionText = await interviewEngine.generateQuestion(
        difficulty, 
        questionNumber, 
        allQuestionsAsked
      );
      
      const newQuestion = {
        id: questionNumber,
        question: questionText,
        difficulty: difficulty,
        timeLimit: timeLimit,
        answered: false,
        answer: null,
        score: null,
        timeTaken: null,
        feedback: null
      };
      
      setActiveQuestion(newQuestion);
      setAllQuestionsAsked(prev => [...prev, questionText]);
      setQuestions(prev => [...prev, newQuestion]);
      
      // Show the question
      const questionMessage = {
        id: Date.now() + 1,
        type: 'bot',
        message: `üìù **Question ${questionNumber}/6** (${difficulty.toUpperCase()}) - ${timeLimit}s

${questionText}

‚è∞ **Timer started!** You have ${timeLimit} seconds to answer.`
      };
      
      setChatMessages(prev => [...prev.slice(0, -1), questionMessage]); // Replace generating message
      
      // Start timer and answering mode
      setCurrentTimer(timeLimit);
      setIsAnswering(true);
      setQuestionStartTime(Date.now());
      setIsGeneratingQuestion(false);
      
    } catch (error) {
      console.error('Failed to generate question:', error);
      
      const errorMessage = {
        id: Date.now(),
        type: 'system',
        message: `‚ùå Failed to generate question: ${error.message}`
      };
      setChatMessages(prev => [...prev, errorMessage]);
      setIsGeneratingQuestion(false);
    }
  };

  const handleTimeExpired = async () => {
    if (!activeQuestion) return;
    
    const timeTaken = activeQuestion.timeLimit;
    
    // Auto-submit with current input or empty answer
    const answer = chatInput.trim() || "No answer provided (time expired)";
    
    // Add time expired message
    const timeExpiredMessage = {
      id: Date.now(),
      type: 'system',
      message: `‚è∞ Time's up! Auto-submitting your answer...`
    };

    setChatMessages(prev => [...prev, timeExpiredMessage]);
    setIsAnswering(false);
    setIsEvaluating(true);
    setChatInput('');

    // Evaluate the answer
    setTimeout(async () => {
      await evaluateCurrentAnswer(answer, timeTaken, true);
    }, 1000);
  };
    
    // Auto-submit with current input or empty answer
    const answer = chatInput.trim() || "No answer provided (time expired)";
    
    // Add time expired message
    const timeExpiredMessage = {
      id: Date.now(),
      type: 'system',
      message: `‚è∞ Time's up! Auto-submitting your answer...`
    };

    setChatMessages(prev => [...prev, timeExpiredMessage]);
    setIsAnswering(false);
    setIsEvaluating(true);
    setChatInput('');

    // Evaluate the answer
    setTimeout(async () => {
      await evaluateCurrentAnswer(answer, timeTaken, true);
    }, 1000);
  };

  const evaluateCurrentAnswer = async (answer, timeTaken, timedOut = false) => {
    const currentQuestion = questions[currentQuestionIndex];
    
    try {
      const evaluation = await interviewEngine.judgeAnswer(
        currentQuestion.question,
        answer,
        currentQuestion.difficulty,
        timeTaken
      );

      // Update question with results
      const updatedQuestions = [...questions];
      updatedQuestions[currentQuestionIndex] = {
        ...currentQuestion,
        answered: true,
        answer: answer,
        score: evaluation.score,
        timeTaken: timeTaken,
        feedback: evaluation.feedback,
        timedOut: timedOut
      };
      setQuestions(updatedQuestions);

      // Show evaluation results
      const evaluationMessage = {
        id: Date.now(),
        type: 'bot',
        message: `üìä **Question ${currentQuestionIndex + 1} Results:**

**Score:** ${evaluation.score}/10
**Accuracy:** ${evaluation.accuracy}%
**Time:** ${timeTaken}s / ${currentQuestion.timeLimit}s
**Difficulty:** ${currentQuestion.difficulty.toUpperCase()}
${timedOut ? '‚è∞ **Time Expired**' : ''}

**AI Feedback:** ${evaluation.feedback}

${currentQuestionIndex < 5 ? '‚è≠Ô∏è Moving to next question...' : 'üéØ Preparing final results...'}`
      };

      setTimeout(() => {
        setChatMessages(prev => [...prev, evaluationMessage]);
        setIsEvaluating(false);
        
        if (currentQuestionIndex < 5) {
          // Move to next question
          setTimeout(() => {
            askNextQuestion(updatedQuestions);
          }, 2000);
        } else {
          // End interview
          setTimeout(async () => {
            await completeInterview(updatedQuestions);
          }, 2000);
        }
      }, 1500);

    } catch (error) {
      console.error('AI Evaluation failed:', error);
      setIsEvaluating(false);
      
      // Show error message to user
      const errorMessage = {
        id: Date.now(),
        type: 'system',
        message: `‚ùå **AI Evaluation Failed**

${error.message}

The interview cannot continue without AI evaluation. Please:
1. Check your internet connection
2. Verify your OpenAI API key in the .env file
3. Ensure you have sufficient API credits

**Interview Paused** - Please refresh and try again once the issue is resolved.`
      };

      setChatMessages(prev => [...prev, errorMessage]);
      
      // Reset interview state
      setIsInterviewStarted(false);
      setIsAnswering(false);
    }
  };

  const askNextQuestion = (currentQuestions) => {
    const nextIndex = currentQuestionIndex + 1;
    const nextQuestion = currentQuestions[nextIndex];
    
    if (nextQuestion) {
      setCurrentQuestionIndex(nextIndex);
      setCurrentTimer(nextQuestion.timeLimit);
      setIsAnswering(true);
      setQuestionStartTime(Date.now());

      const questionMessage = {
        id: Date.now(),
        type: 'bot',
        message: `üìã **Question ${nextIndex + 1}/6** (${nextQuestion.difficulty.toUpperCase()})

${nextQuestion.question}

‚è±Ô∏è **Time Limit: ${nextQuestion.timeLimit} seconds**
üí° **Points: ${interviewEngine.difficultyConfig[nextQuestion.difficulty].points}**

Please provide your answer:`
      };

      setChatMessages(prev => [...prev, questionMessage]);
    }
  };

  const completeInterview = async (finalQuestions) => {
    try {
      const results = await interviewEngine.endInterview(finalQuestions);
      
      const finalMessage = {
        id: Date.now(),
        type: 'bot',
        message: `üéâ **Interview Complete!**

üìä **Final Results:**
‚Ä¢ **Overall Score:** ${results.averageScore}/10 (${results.percentageScore}%)
‚Ä¢ **Questions Completed:** ${results.totalQuestions}/6
‚Ä¢ **Points Earned:** ${results.earnedPoints}/${results.totalPossiblePoints}

üìà **Performance by Difficulty:**
‚Ä¢ **Easy:** ${results.difficultyBreakdown.easy.map(q => q.score).join(', ')}/10
‚Ä¢ **Medium:** ${results.difficultyBreakdown.medium.map(q => q.score).join(', ')}/10  
‚Ä¢ **Hard:** ${results.difficultyBreakdown.hard.map(q => q.score).join(', ')}/10

üéØ **AI-Generated Summary:**
${results.summary}

Thank you for completing the React/Node.js Full Stack Developer interview! üöÄ`
      };

      setTimeout(() => {
        setChatMessages(prev => [...prev, finalMessage]);
        setInterviewResults(results);
      }, 1000);
      
    } catch (error) {
      console.error('Failed to complete interview:', error);
      
      // Show error message for summary generation failure
      const errorMessage = {
        id: Date.now(),
        type: 'system',
        message: `‚ö†Ô∏è **Interview Complete - Summary Generation Failed**

Your interview has been completed, but we couldn't generate the AI summary due to:

${error.message}

**Your Performance:**
‚Ä¢ **Questions Completed:** ${finalQuestions.length}/6
‚Ä¢ **Average Score:** ${(finalQuestions.reduce((sum, q) => sum + q.score, 0) / finalQuestions.length).toFixed(1)}/10

Please ensure your OpenAI API key is properly configured for AI-generated summaries.`
      };

      setTimeout(() => {
        setChatMessages(prev => [...prev, errorMessage]);
      }, 1000);
    }
  };

  const handleFileSelect = (file) => {
    setUploadedFile(file);
    if (file) {
      console.log("File selected:", file.name, "Size:", file.size, "Type:", file.type);
    } else {
      console.log("File removed");
      setCurrentStep(0);
      setMissingFields([]);
      setCurrentMissingFieldIndex(0);
      setChatInput('');
    }
  };

  const handleTextExtracted = (data) => {
    setExtractedData(data);
    if (data && data.success) {
      console.log("Text extraction successful:", {
        textLength: data.text.length,
        fileType: data.fileType,
        resumeInfo: data.resumeInfo
      });
      
      // Check for missing fields
      const missing = [];
      if (!data.data?.name || data.data.name === 'Name not found') missing.push('name');
      if (!data.data?.email || data.data.email === 'Email not found') missing.push('email');
      if (!data.data?.phone || data.data.phone === 'Phone not found') missing.push('phone');
      
      setMissingFields(missing);
      setCurrentMissingFieldIndex(0);
      
      // Initialize chat messages
      const initialMessages = [];
      
      if (missing.length > 0) {
        // Add message about missing fields
        initialMessages.push({
          id: Date.now(),
          type: 'bot',
          message: `I notice ${missing.length} field${missing.length > 1 ? 's are' : ' is'} missing from your resume: ${missing.map(field => {
            const fieldNames = { name: 'Name', email: 'Email', phone: 'Phone' };
            return fieldNames[field];
          }).join(', ')}. Let me collect this information from you.`
        });
        
        // Add first field request
        const firstField = missing[0];
        const fieldLabels = {
          name: 'your full name',
          email: 'your email address', 
          phone: 'your phone number'
        };
        const fieldIcons = {
          name: 'üë§',
          email: 'üìß',
          phone: 'üì±'
        };
        
        initialMessages.push({
          id: Date.now() + 1,
          type: 'bot',
          message: `${fieldIcons[firstField]} Please enter ${fieldLabels[firstField]}:`
        });
      }
      
      setChatMessages(initialMessages);
      setCurrentStep(1);
    } else if (data === null) {
      setExtractedData(null);
      setCurrentStep(0);
      setMissingFields([]);
      setCurrentMissingFieldIndex(0);
      setChatInput('');
      setChatMessages([]);
    }
  };

  const handleInputChange = (field, value) => {
    setUserInputs(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleChatSubmit = () => {
    if (!chatInput.trim()) return;

    // Add user message to chat
    const userMessage = {
      id: Date.now(),
      type: 'user',
      message: chatInput.trim()
    };

    if (missingFields.length > 0 && currentMissingFieldIndex < missingFields.length) {
      // Handle missing field input
      const currentField = missingFields[currentMissingFieldIndex];

      // Name validation
      if (currentField === 'name' && !nameRegex.test(chatInput.trim())) {
        setChatMessages(prev => [
          ...prev,
          userMessage,
          {
            id: Date.now() + 1,
            type: 'bot',
            message: '‚ùå Please enter a valid name (letters and spaces only, at least 2 characters).'
          }
        ]);
        setChatInput('');
        return;
      }
      // Email validation
      if (currentField === 'email' && !emailRegex.test(chatInput.trim())) {
        setChatMessages(prev => [
          ...prev,
          userMessage,
          {
            id: Date.now() + 1,
            type: 'bot',
            message: '‚ùå Please enter a valid email address (e.g. user@example.com).'
          }
        ]);
        setChatInput('');
        return;
      }
      // Phone validation
      if (currentField === 'phone' && !phoneRegex.test(chatInput.trim())) {
        setChatMessages(prev => [
          ...prev,
          userMessage,
          {
            id: Date.now() + 1,
            type: 'bot',
            message: '‚ùå Please enter a valid phone number (10-15 digits, may include +, -, spaces).'
          }
        ]);
        setChatInput('');
        return;
      }

      handleInputChange(currentField, chatInput.trim());
      // Add user response to chat
      setChatMessages(prev => [...prev, userMessage]);

      if (currentMissingFieldIndex === missingFields.length - 1) {
        // Last missing field - submit all and show completion
        const updatedData = { ...extractedData };
        missingFields.forEach((field, index) => {
          if (index < missingFields.length - 1) {
            updatedData.data[field] = userInputs[field];
          } else {
            updatedData.data[field] = chatInput.trim();
          }
        });
        setExtractedData(updatedData);

        // Add bot completion message
        const completionMessage = {
          id: Date.now() + 1,
          type: 'bot',
          message: `Perfect! ‚úÖ I now have all your information. Here's what I collected:

üë§ **Name:** ${updatedData.data.name}
üìß **Email:** ${updatedData.data.email}
üì± **Phone:** ${updatedData.data.phone}

Now I'm ready to start the interview. Are you ready to begin?`
        };

        setTimeout(() => {
          setChatMessages(prev => [...prev, completionMessage]);
        }, 500);

        setMissingFields([]);
        setCurrentMissingFieldIndex(0);
      } else {
        // Move to next missing field
        const nextIndex = currentMissingFieldIndex + 1;
        const nextField = missingFields[nextIndex];
        const fieldLabels = {
          name: 'your full name',
          email: 'your email address', 
          phone: 'your phone number'
        };
        const fieldIcons = {
          name: 'üë§',
          email: 'üìß',
          phone: 'üì±'
        };

        // Add bot response and next field request
        const botMessages = [
          {
            id: Date.now() + 1,
            type: 'bot',
            message: `Great! Got your ${currentField}. ‚úÖ`
          },
          {
            id: Date.now() + 2,
            type: 'bot',
            message: `${fieldIcons[nextField]} Now, please enter ${fieldLabels[nextField]}:`
          }
        ];

        setTimeout(() => {
          setChatMessages(prev => [...prev, ...botMessages]);
        }, 500);

        setCurrentMissingFieldIndex(nextIndex);
      }
      setChatInput('');
    } else if (!isInterviewStarted && (chatInput.toLowerCase().includes('yes') || chatInput.toLowerCase().includes('ready') || chatInput.toLowerCase().includes('start'))) {
      // Start the interview
      setChatMessages(prev => [...prev, userMessage]);
      setIsInterviewStarted(true);
      
      const startMessages = [
        {
          id: Date.now() + 1,
          type: 'bot',
          message: "üöÄ **Starting Interview!** Generating your personalized question set..."
        }
      ];

      setTimeout(() => {
        setChatMessages(prev => [...prev, ...startMessages]);
      }, 500);

      // Generate questions and start
      setTimeout(async () => {
        try {
          const generatedQuestions = await interviewEngine.generateQuestionSet();
          setQuestions(generatedQuestions);
          setCurrentQuestionIndex(0);
          setCurrentTimer(generatedQuestions[0].timeLimit);
          setIsAnswering(true);
          setQuestionStartTime(Date.now());

          const firstQuestionMessage = {
            id: Date.now(),
            type: 'bot',
            message: `üìã **Question 1/6** (${generatedQuestions[0].difficulty.toUpperCase()})

${generatedQuestions[0].question}

‚è±Ô∏è **Time Limit: ${generatedQuestions[0].timeLimit} seconds**
üí° **Points: ${interviewEngine.difficultyConfig[generatedQuestions[0].difficulty].points}**

Please provide your answer:`
          };

          setChatMessages(prev => [...prev, firstQuestionMessage]);
        } catch (error) {
          console.error('Failed to start interview:', error);
        }
      }, 1500);

      setChatInput('');
    } else if (isAnswering && !isEvaluating) {
      // Handle interview answer submission
      setChatMessages(prev => [...prev, userMessage]);
      setIsAnswering(false);
      setIsEvaluating(true);
      
      const timeTaken = Math.floor((Date.now() - questionStartTime) / 1000);
      
      // Clear timer
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }

      // Show evaluation message
      const evaluatingMessage = {
        id: Date.now() + 1,
        type: 'bot',
        message: "Thank you for your answer! Let me evaluate it using AI... ü§î"
      };

      setTimeout(() => {
        setChatMessages(prev => [...prev, evaluatingMessage]);
      }, 500);

      // Evaluate the answer
      setTimeout(async () => {
        await evaluateCurrentAnswer(chatInput.trim(), timeTaken, false);
      }, 1500);

      setChatInput('');
    } else {
      // Default response
      setChatMessages(prev => [...prev, userMessage]);
      
      const botResponse = {
        id: Date.now() + 1,
        type: 'bot',
        message: "I understand. Is there anything specific you'd like to discuss about the interview?"
      };

      setTimeout(() => {
        setChatMessages(prev => [...prev, botResponse]);
      }, 500);
      
      setChatInput('');
    }
  };

  const steps = [
    {
      title: 'Upload Resume',
      description: 'Upload your resume to get started',
      icon: <FileTextOutlined />,
    },
    {
      title: 'Chat Interview',
      description: 'Answer questions based on your resume',
      icon: <MessageOutlined />,
    },
  ];

  return (
    <div style={{ padding: '20px', maxWidth: '800px', margin: '0 auto' }}>
      <Title level={2}>AI Interview - Interviewee Portal</Title>
      
      <Card style={{ marginBottom: '20px' }}>
        <Steps current={currentStep} items={steps} />
      </Card>

      {currentStep === 0 && (
        <Card title="Step 1: Upload Your Resume" style={{ marginBottom: '20px' }}>
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <Text type="secondary">
              Please upload your resume to begin the AI interview process. We accept PDF, DOC, and DOCX files.
            </Text>
            
            <ResumeUpload 
              onFileSelect={handleFileSelect} 
              onTextExtracted={handleTextExtracted}
            />
            
            {uploadedFile && extractedData && extractedData.success && (
              <>
                <Divider />
                <div>
                  <Title level={4}>Resume Successfully Processed! ‚úÖ</Title>
                  <Space direction="vertical" size="small">
                    <Text><strong>File:</strong> {uploadedFile.name}</Text>
                    <Text><strong>Size:</strong> {(uploadedFile.size / 1024 / 1024).toFixed(2)} MB</Text>
                    <Text><strong>Type:</strong> {extractedData.fileType.toUpperCase()}</Text>
                    <Text><strong>Content:</strong> {extractedData.resumeInfo.wordCount} words extracted</Text>
                    <Text><strong>Sections Found:</strong> {extractedData.resumeInfo.sections.join(', ')}</Text>
                  </Space>
                  <div style={{ marginTop: '16px' }}>
                    <Button 
                      type="primary" 
                      size="large"
                      onClick={() => setCurrentStep(1)}
                    >
                      Start Interview Process
                    </Button>
                  </div>
                </div>
              </>
            )}
          </Space>
        </Card>
      )}

      {currentStep === 1 && (
        <Card title="Step 2: Chat Interview" style={{ marginBottom: '20px' }}>
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            
            {/* Chat Interface */}
            <div style={{ 
              height: '400px', 
              border: '1px solid #d9d9d9', 
              borderRadius: '8px', 
              padding: '16px',
              backgroundColor: '#fafafa',
              overflowY: 'auto'
            }}
            ref={chatContainerRef}>
              
              {/* Timer Display */}
              {isAnswering && (
                <div style={{
                  position: 'sticky',
                  top: 0,
                  backgroundColor: '#fff2e8',
                  padding: '8px 16px',
                  borderRadius: '8px',
                  border: '1px solid #ffb366',
                  marginBottom: '16px',
                  textAlign: 'center',
                  zIndex: 1000
                }}>
                  <Space>
                    <ClockCircleOutlined style={{ color: '#fa8c16' }} />
                    <Text strong style={{ color: '#fa8c16' }}>
                      Time Remaining: {Math.floor(currentTimer / 60)}:{(currentTimer % 60).toString().padStart(2, '0')}
                    </Text>
                    <Text type="secondary" style={{ fontSize: '12px' }}>
                      Question {currentQuestionIndex + 1}/6 ({questions[currentQuestionIndex]?.difficulty?.toUpperCase()})
                    </Text>
                  </Space>
                  <Progress 
                    percent={questions[currentQuestionIndex] ? ((questions[currentQuestionIndex].timeLimit - currentTimer) / questions[currentQuestionIndex].timeLimit) * 100 : 0}
                    showInfo={false}
                    strokeColor={currentTimer < 10 ? '#ff4d4f' : currentTimer < 30 ? '#fa8c16' : '#52c41a'}
                    style={{ marginTop: '8px' }}
                  />
                </div>
              )}

              {/* AI Welcome Message */}
              <div style={{ marginBottom: '16px' }}>
                <div style={{
                  backgroundColor: '#e6f7ff',
                  padding: '12px',
                  borderRadius: '12px',
                  maxWidth: '70%',
                  marginBottom: '8px'
                }}>
                  <Text style={{ fontSize: '14px' }}>
                    ü§ñ <strong>AI Interviewer:</strong> Hello! I've successfully processed your resume. Let me show you what I extracted:
                  </Text>
                </div>
              </div>

              {/* Show Extracted Data */}
              {extractedData && extractedData.data && (
                <>
                  <div style={{ marginBottom: '16px' }}>
                    <div style={{
                      backgroundColor: '#e6f7ff',
                      padding: '12px',
                      borderRadius: '12px',
                      maxWidth: '70%',
                      marginBottom: '8px'
                    }}>
                      <Text style={{ fontSize: '14px' }}>
                        I found the following personal information in your resume:
                      </Text>
                    </div>
                  </div>

                  <div style={{ marginBottom: '16px' }}>
                    <div style={{
                      backgroundColor: '#f6ffed',
                      padding: '12px',
                      borderRadius: '12px',
                      maxWidth: '70%',
                      border: '1px solid #b7eb8f'
                    }}>
                      <Space direction="vertical" size="small">
                        <Text style={{ fontSize: '14px' }}>
                          üë§ <strong>Name:</strong> {extractedData.data.name}
                        </Text>
                        <Text style={{ fontSize: '14px' }}>
                          üìß <strong>Email:</strong> {extractedData.data.email}
                        </Text>
                        <Text style={{ fontSize: '14px' }}>
                          üì± <strong>Phone:</strong> {extractedData.data.phone}
                        </Text>
                      </Space>
                    </div>
                  </div>
                </>
              )}

              {/* Chat Messages */}
              {chatMessages.map((msg) => (
                <div key={msg.id} style={{ 
                  marginBottom: '16px',
                  textAlign: msg.type === 'user' ? 'right' : 'left'
                }}>
                  <div style={{
                    backgroundColor: 
                      msg.type === 'user' ? '#1890ff' : 
                      msg.type === 'system' ? '#fff1f0' :
                      msg.message.includes('missing') ? '#fff7e6' : '#e6f7ff',
                    color: msg.type === 'user' ? '#fff' : '#000',
                    padding: '12px',
                    borderRadius: '12px',
                    maxWidth: '70%',
                    marginLeft: msg.type === 'user' ? 'auto' : '0',
                    marginRight: msg.type === 'user' ? '0' : 'auto',
                    border: 
                      msg.type === 'system' ? '1px solid #ffccc7' :
                      msg.type === 'bot' && msg.message.includes('missing') ? '1px solid #ffd591' : 'none',
                    whiteSpace: 'pre-line'
                  }}>
                    <Text style={{ 
                      fontSize: '14px',
                      color: msg.type === 'user' ? '#fff' : msg.type === 'system' ? '#cf1322' : '#000'
                    }}>
                      {msg.type === 'bot' && 'ü§ñ '}
                      {msg.type === 'system' && '‚ö†Ô∏è '}
                      {msg.message}
                    </Text>
                  </div>
                </div>
              ))}
            </div>

            {/* Smart Chat Input Area */}
            <div style={{
              display: 'flex',
              gap: '8px',
              padding: '16px',
              backgroundColor: '#f9f9f9',
              borderRadius: '8px',
              border: '1px solid #d9d9d9'
            }}>
              <input
                type="text"
                placeholder={
                  missingFields.length > 0 && currentMissingFieldIndex < missingFields.length
                    ? "Type your response here..."
                    : "Type your message here..."
                }
                value={chatInput}
                onChange={(e) => setChatInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleChatSubmit();
                  }
                }}
                style={{
                  flex: 1,
                  padding: '8px 12px',
                  border: '1px solid #d9d9d9',
                  borderRadius: '4px',
                  fontSize: '14px',
                  backgroundColor: '#fff'
                }}
                disabled={!extractedData}
              />
              <Button 
                type="primary" 
                onClick={handleChatSubmit}
                disabled={!extractedData || !chatInput.trim()}
              >
                Send
              </Button>
            </div>

            {/* Help text */}
            <Text type="secondary" style={{ textAlign: 'center', display: 'block', fontSize: '12px' }}>
              {missingFields.length > 0 ? 
                `Please provide the requested information in the chat above` : 
                `Chat with the AI interviewer`
              }
            </Text>
          </Space>
        </Card>
      )}

      {/* Video interview step removed as requested */}
    </div>
  );
};

export default Chat